import time
import struct

from PicoControl.Com.tmf8821.com.i2c_com import I2C_com
from PicoControl.Com.tmf8821.tmf8821_device import Tmf8821Device

# constants for all classes
TMF882X_APP_MAX_ZONES = 18  # time-multiplexe maximum of 18 zones produce a result
TMF882X_MAX_NUMBER_OF_RESULTS = TMF882X_APP_MAX_ZONES * 2  # 2 objects per zone
TMF882X_BINS = 128  # how many bytes are in a histogram sub-packet


class LittleEndianStructure:
    _fields_ = []

    last_unpacked = {}

    """Do not update this directly"""
    packet_string_struct = "<"

    def __init__(self):
        for entry in self._fields_:
            key, value = entry

            if type(value) == type(type):
                instance = value()
                self._fields_[self._fields_.index(entry)] = (key, instance)
                self.packet_string_struct = "object"
            elif self.packet_string_struct != "object":
                self.packet_string_struct += value
            else:
                raise ValueError("Structure cannot contain mixed values")

    def get_size(self):
        return struct.calcsize(self.packet_string_struct)

    def print(self):
        print(self.last_unpacked)

    def unpack(self, pdata):
        result = {}
        if self.packet_string_struct == "object":
            for entry in self._fields_:
                key, value = entry
                cut = pdata[:value.get_size()]
                pdata = pdata[value.get_size():]
                result[key] = value.unpack(pdata=cut)
        else:
            size = self.get_size()
            unpacked = struct.unpack(self.packet_string_struct, pdata[:size])

            for entry in self._fields_:
                key, value = entry
                result[key] = unpacked[self._fields_.index(entry)]

        self.last_unpacked = result
        return result


class TMF8821ResultPayload(LittleEndianStructure):
    _fields_ = [
        ("resultNumber", 'B'),
        ("temperature", 'B',),
        ("numberValidResults", 'B'),
        ("reserved0", 'B'),
        ("ambientLight", 'I'),
        ("photonCount", 'I'),
        ("referencePhotonCount", 'I'),
        ("systemTicks", 'I')
    ]

    resultNumber = 0
    temperature = 0
    numberValidResults = 0
    reserved0 = 0
    ambientLight = 0
    photonCount = 0
    referencePhotonCount = 0
    systemTicks = 0

    def unpack(self, pdata):
        unpacked = super().unpack(pdata)
        self.resultNumber = unpacked["resultNumber"]
        self.temperature = unpacked["temperature"]
        self.numberValidResults = unpacked["numberValidResults"]
        self.reserved0 = unpacked["reserved0"]
        self.ambientLight = unpacked["ambientLight"]
        self.photonCount = unpacked["photonCount"]
        self.referencePhotonCount = unpacked["referencePhotonCount"]
        self.systemTicks = unpacked["systemTicks"]


class TMF8821ResultHeader(LittleEndianStructure):
    _fields_ = [
        ("cid_rid", 'B'),
        ("tid", 'B'),
        ("payload", 'H'),
    ]

    cid_rid = 0
    tid = 0
    payload = 0

    def __init__(self):
        super().__init__()

    def unpack(self, pdata):
        unpacked = super().unpack(pdata)
        self.cid_rid = unpacked["cid_rid"]
        self.tid = unpacked["tid"]
        self.payload = unpacked["payload"]


class TMF8821MeasureResult(LittleEndianStructure):
    _fields_ = [
        ("confidence", 'B'),
        ("distanceInMm", 'H')
    ]

    confidence = 0
    distanceInMm = 0

    def __init__(self):
        super().__init__()

    def unpack(self, pdata):
        unpacked = super().unpack(pdata)
        self.confidence = unpacked["confidence"]
        self.distanceInMm = unpacked["distanceInMm"]
        
    def print(self):
        print(self.distanceInMm, ", ", self.confidence)


class TMF8821ResultFrame(LittleEndianStructure):
    _fields_ = []

    header = TMF8821ResultHeader()
    payload = TMF8821ResultPayload()
    results = []

    def __init__(self):
        super().__init__()

    def unpack(self, pdata):
        self.header.unpack(pdata[:self.header.get_size()])
        pdata = pdata[self.header.get_size():]
        self.payload.unpack(pdata[:self.payload.get_size()])
        pdata = pdata[self.payload.get_size():]
        self.results = []
        for i in range(0, self.payload.numberValidResults):
            entry = TMF8821MeasureResult()
            entry.unpack(pdata[:entry.get_size()])
            pdata = pdata[entry.get_size():]
            self.results.append(entry)

    def print(self):
        self.header.print()
        self.payload.print()
        self.print_results()

    def __len__(self):
        return len(self.results)

    def print_results(self):
        for result in self.results:
            result.print()


class BinaryImage:
    TOF_IMAGE = bytearray([
        0x00, 0x80, 0x20, 0x00, 0x9D, 0x00, 0x20, 0x00, 0xD5, 0x20, 0x10, 0x00,
        0xD7, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x09, 0x12, 0x56, 0x34, 0xAC, 0x09, 0x00, 0x00, 0xD9, 0x20, 0x10, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDB, 0x20, 0x10, 0x00,
        0xDD, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xAD, 0x22, 0x10, 0x00,
        0x61, 0x23, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0x85, 0x22, 0x10, 0x00,
        0x99, 0x22, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00,
        0xDF, 0x20, 0x10, 0x00, 0x51, 0x23, 0x10, 0x00, 0xE1, 0x20, 0x10, 0x00,
        0xE1, 0x20, 0x10, 0x00, 0x05, 0x24, 0x10, 0x00, 0x2D, 0x24, 0x10, 0x00,
        0x4D, 0x24, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00, 0xDF, 0x20, 0x10, 0x00,
        0x53, 0x29, 0xCD, 0x68, 0x03, 0x48, 0x85, 0x46, 0x00, 0xF0, 0x16, 0xF8,
        0x00, 0x48, 0x00, 0x47, 0xE1, 0x00, 0x20, 0x00, 0x00, 0x80, 0x20, 0x00,
        0x05, 0x48, 0x80, 0x47, 0x05, 0x48, 0x00, 0x47, 0xFE, 0xE7, 0xFE, 0xE7,
        0xFE, 0xE7, 0xFE, 0xE7, 0x70, 0x47, 0xFE, 0xE7, 0x70, 0x47, 0x00, 0x00,
        0xED, 0x6D, 0x10, 0x00, 0x89, 0x00, 0x20, 0x00, 0x06, 0x4C, 0x01, 0x25,
        0x06, 0x4E, 0x05, 0xE0, 0xE3, 0x68, 0x07, 0xCC, 0x2B, 0x43, 0x0C, 0x3C,
        0x98, 0x47, 0x10, 0x34, 0xB4, 0x42, 0xF7, 0xD3, 0xFF, 0xF7, 0xDC, 0xFF,
        0xAC, 0x09, 0x20, 0x00, 0xAC, 0x09, 0x20, 0x00, 0x10, 0xB5, 0x00, 0xF0,
        0x01, 0xF9, 0x00, 0xF0, 0x2D, 0xF9, 0x10, 0xBD, 0xF3, 0xB5, 0x8D, 0xB0,
        0x04, 0xF7, 0x82, 0xFA, 0x30, 0x30, 0x0C, 0x90, 0x58, 0x48, 0x18, 0x21,
        0x41, 0x56, 0x58, 0x20, 0x41, 0x43, 0x0C, 0x98, 0x08, 0x30, 0x0C, 0x18,
        0x00, 0xBF, 0x00, 0x26, 0x00, 0x21, 0x53, 0x48, 0x60, 0x38, 0x01, 0x77,
        0x0D, 0x98, 0x08, 0x90, 0x50, 0x48, 0x00, 0x69, 0x06, 0x90, 0xC8, 0x21,
        0x4E, 0x48, 0x01, 0x61, 0x00, 0x20, 0x07, 0xAB, 0x01, 0x90, 0x02, 0x90,
        0x00, 0x93, 0x03, 0x90, 0x4B, 0x48, 0x01, 0x23, 0x09, 0xAA, 0x80, 0x21,
        0x45, 0x6B, 0x08, 0x98, 0xA8, 0x47, 0x05, 0x90, 0x46, 0x49, 0x06, 0x98,
        0x08, 0x61, 0x05, 0x98, 0x01, 0x28, 0x07, 0xDA, 0x01, 0x20, 0xC0, 0x03,
        0xA0, 0x60, 0x44, 0x48, 0x20, 0x63, 0x76, 0x1C, 0x00, 0xBF, 0x03, 0xE0,
        0x09, 0x98, 0xA0, 0x60, 0x0A, 0x98, 0x20, 0x63, 0xA0, 0x68, 0x04, 0x90,
        0x01, 0x25, 0x54, 0xE0, 0x69, 0x02, 0x0D, 0x98, 0x08, 0x18, 0x08, 0x90,
        0x00, 0x20, 0x07, 0xAA, 0x02, 0x90, 0x01, 0x95, 0x00, 0x92, 0x03, 0x90,
        0x37, 0x48, 0x01, 0x23, 0x09, 0xAA, 0x80, 0x21, 0x47, 0x6B, 0x08, 0x98,
        0xB8, 0x47, 0x05, 0x90, 0x05, 0x98, 0x01, 0x28, 0x0C, 0xDA, 0x76, 0x1C,
        0xAA, 0x00, 0x21, 0x46, 0x08, 0x31, 0x04, 0x98, 0x88, 0x50, 0x01, 0x21,
        0xAA, 0x00, 0x20, 0x46, 0x30, 0x30, 0x81, 0x50, 0x00, 0xBF, 0x31, 0xE0,
        0x05, 0x22, 0xD2, 0x03, 0x04, 0x98, 0x80, 0x1A, 0x09, 0x99, 0x81, 0x42,
        0x04, 0xD3, 0x04, 0x98, 0x80, 0x18, 0x09, 0x99, 0x81, 0x42, 0x15, 0xD9,
        0xAA, 0x00, 0x20, 0x46, 0x08, 0x30, 0xA1, 0x68, 0x81, 0x50, 0xAA, 0x00,
        0x28, 0x30, 0x21, 0x6B, 0x81, 0x50, 0x02, 0x21, 0xAA, 0x00, 0x81, 0x50,
        0xA9, 0x00, 0x40, 0x58, 0x20, 0x49, 0x88, 0x42, 0x01, 0xD9, 0x00, 0xBF,
        0x00, 0xBF, 0x76, 0x1C, 0x00, 0xBF, 0x0F, 0xE0, 0xAA, 0x00, 0x20, 0x46,
        0x08, 0x30, 0x09, 0x99, 0x81, 0x50, 0xAA, 0x00, 0x28, 0x30, 0x0A, 0x99,
        0x81, 0x50, 0xA9, 0x00, 0x40, 0x58, 0x17, 0x49, 0x88, 0x42, 0x01, 0xD9,
        0x00, 0xBF, 0x00, 0xBF, 0x6D, 0x1C, 0x0A, 0x2D, 0xA8, 0xDB, 0x00, 0x20,
        0x0E, 0xE0, 0x82, 0x00, 0x21, 0x46, 0x30, 0x31, 0x8B, 0x58, 0x0D, 0x4A,
        0x18, 0x21, 0x51, 0x56, 0x28, 0x22, 0x51, 0x43, 0x0A, 0x4A, 0x40, 0x3A,
        0x89, 0x18, 0x82, 0x00, 0x8B, 0x50, 0x40, 0x1C, 0x0A, 0x28, 0xEE, 0xDB,
        0x01, 0x21, 0x06, 0x48, 0x60, 0x38, 0x01, 0x77, 0x00, 0x2E, 0x01, 0xD1,
        0x00, 0xBF, 0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0x0F, 0xB0,
        0xF0, 0xBD, 0x00, 0x00, 0x80, 0x3B, 0x20, 0x00, 0x38, 0x3C, 0x20, 0x00,
        0xD2, 0x04, 0x00, 0x00, 0x60, 0xEA, 0x00, 0x00, 0x30, 0xB5, 0x04, 0x46,
        0x0B, 0x48, 0x84, 0x42, 0x01, 0xDD, 0xFF, 0x20, 0x30, 0xBD, 0x29, 0x2C,
        0x01, 0xDA, 0x20, 0x46, 0xFA, 0xE7, 0x20, 0x46, 0x00, 0xF0, 0x12, 0xF8,
        0x06, 0x49, 0x40, 0x1A, 0x06, 0x49, 0x48, 0x43, 0x00, 0x12, 0x05, 0x21,
        0xC9, 0x02, 0x45, 0x18, 0x28, 0x46, 0x80, 0x30, 0x00, 0x12, 0xEB, 0xE7,
        0x24, 0x84, 0x2E, 0x00, 0x52, 0x05, 0x00, 0x00, 0x42, 0x0D, 0x00, 0x00,
        0x10, 0xB5, 0x03, 0x46, 0x19, 0x02, 0x00, 0x20, 0x80, 0x22, 0x03, 0xE0,
        0x4C, 0x1C, 0x61, 0x10, 0xFF, 0x30, 0x01, 0x30, 0x01, 0x24, 0x64, 0x02,
        0xA1, 0x42, 0xF7, 0xDC, 0x00, 0xBF, 0x0C, 0x46, 0x4C, 0x43, 0x21, 0x12,
        0x01, 0x24, 0x64, 0x02, 0xA1, 0x42, 0x02, 0xDB, 0x4C, 0x1C, 0x61, 0x10,
        0x80, 0x18, 0x52, 0x10, 0x00, 0x2A, 0xF2, 0xD1, 0x10, 0xBD, 0x00, 0x00,
        0x10, 0xB5, 0x02, 0xF7, 0x6B, 0xFC, 0x0E, 0x48, 0x0E, 0x49, 0xC8, 0x60,
        0x0E, 0x48, 0x0F, 0x49, 0x88, 0x63, 0x0F, 0x48, 0xC8, 0x64, 0x00, 0x20,
        0x06, 0xE0, 0x41, 0x00, 0x0D, 0x4A, 0x52, 0x5A, 0x43, 0x00, 0x0D, 0x49,
        0xCA, 0x52, 0x40, 0x1C, 0x21, 0x28, 0xF6, 0xDB, 0x02, 0x21, 0x03, 0x20,
        0x04, 0xF7, 0xF0, 0xFD, 0x03, 0x21, 0x08, 0x46, 0x04, 0xF7, 0xEC, 0xFD,
        0x10, 0xBD, 0x00, 0x00, 0x1D, 0x09, 0x20, 0x00, 0x38, 0x3F, 0x20, 0x00,
        0x4D, 0x03, 0x20, 0x00, 0x38, 0x3C, 0x20, 0x00, 0xED, 0x00, 0x20, 0x00,
        0x68, 0x09, 0x20, 0x00, 0xF6, 0x3A, 0x20, 0x00, 0x10, 0xB5, 0x02, 0xF7,
        0x55, 0xFD, 0x10, 0xBD, 0xF7, 0xB5, 0xA4, 0xB0, 0x14, 0x46, 0x04, 0xF7,
        0x51, 0xF9, 0x18, 0x90, 0x00, 0x2C, 0x05, 0xD1, 0xF7, 0x48, 0x00, 0x8A,
        0x40, 0x1C, 0x81, 0xB2, 0xF5, 0x48, 0x01, 0x82, 0x04, 0xF7, 0x46, 0xF9,
        0x06, 0x46, 0x30, 0x36, 0x24, 0x22, 0x00, 0x21, 0x1A, 0xA8, 0x07, 0xF7,
        0xC3, 0xFC, 0x24, 0x98, 0x19, 0x90, 0xF0, 0x48, 0x40, 0x68, 0x16, 0x90,
        0xED, 0x48, 0x80, 0x38, 0x00, 0x69, 0x15, 0x90, 0xC8, 0x21, 0xEB, 0x48,
        0x80, 0x38, 0x01, 0x61, 0x00, 0x20, 0x17, 0xAB, 0x01, 0x90, 0x02, 0x90,
        0x00, 0x93, 0x03, 0x90, 0xE8, 0x48, 0x01, 0x23, 0x1A, 0xAA, 0x80, 0x21,
        0x45, 0x6B, 0x19, 0x98, 0xA8, 0x47, 0x14, 0x90, 0xE2, 0x49, 0x80, 0x39,
        0x15, 0x98, 0x08, 0x61, 0xE1, 0x49, 0x16, 0x98, 0x48, 0x60, 0x14, 0x98,
        0x00, 0x28, 0x02, 0xD1, 0x24, 0x20, 0x27, 0xB0, 0xF0, 0xBD, 0xDF, 0x48,
        0x13, 0x90, 0xDD, 0x48, 0x22, 0x46, 0x80, 0x21, 0x83, 0x6E, 0x13, 0x98,
        0x98, 0x47, 0x00, 0x2C, 0x07, 0xD1, 0x00, 0x20, 0xD7, 0x49, 0x48, 0x60,
        0x88, 0x60, 0xD9, 0x49, 0xD4, 0x48, 0x80, 0x38, 0xC1, 0x61, 0x1A, 0x98,
        0xC0, 0x13, 0x12, 0x90, 0x12, 0x98, 0x40, 0x1E, 0x81, 0x00, 0x19, 0x98,
        0x41, 0x58, 0x12, 0x98, 0x82, 0x00, 0x19, 0x98, 0x80, 0x58, 0x09, 0x18,
        0x12, 0x98, 0x40, 0x1C, 0x82, 0x00, 0x19, 0x98, 0x80, 0x58, 0x08, 0x18,
        0xCA, 0x49, 0xC8, 0x60, 0xC8, 0x48, 0xE0, 0x38, 0x00, 0x7F, 0x00, 0x28,
        0x32, 0xD1, 0x58, 0x20, 0x60, 0x43, 0x31, 0x46, 0x08, 0x31, 0x40, 0x18,
        0x1A, 0x9A, 0x82, 0x60, 0xC7, 0x4A, 0x58, 0x20, 0x60, 0x43, 0x40, 0x18,
        0x02, 0x63, 0x01, 0x21, 0xC9, 0x03, 0xC5, 0x48, 0x81, 0x63, 0x01, 0x20,
        0x1C, 0xE0, 0x58, 0x21, 0x61, 0x43, 0x32, 0x46, 0x08, 0x32, 0x89, 0x18,
        0x8B, 0x68, 0x58, 0x21, 0x61, 0x43, 0x89, 0x18, 0x08, 0x31, 0x82, 0x00,
        0x8B, 0x50, 0x03, 0x23, 0x58, 0x21, 0x61, 0x43, 0x32, 0x46, 0x08, 0x32,
        0x89, 0x18, 0x30, 0x31, 0x82, 0x00, 0x8B, 0x50, 0x28, 0x21, 0x61, 0x43,
        0xB7, 0x4A, 0x40, 0x32, 0x89, 0x18, 0x82, 0x00, 0x8B, 0x50, 0x40, 0x1C,
        0x0A, 0x28, 0xE0, 0xDB, 0x00, 0xBF, 0x1E, 0xE0, 0x04, 0xF7, 0xB6, 0xF8,
        0x05, 0x46, 0x30, 0x35, 0xB0, 0x48, 0x80, 0x38, 0x40, 0x68, 0x00, 0x28,
        0x03, 0xD0, 0xBA, 0x20, 0x40, 0x5B, 0x00, 0x28, 0x04, 0xD1, 0x01, 0x21,
        0xC9, 0x03, 0xAB, 0x48, 0x81, 0x63, 0x09, 0xE0, 0xBA, 0x22, 0x51, 0x5B,
        0xA8, 0x4A, 0x80, 0x3A, 0x52, 0x68, 0xD0, 0x03, 0xFF, 0xF6, 0x3C, 0xFE,
        0xA5, 0x49, 0x88, 0x63, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20,
        0x22, 0xE0, 0x01, 0x21, 0x1D, 0xE0, 0x58, 0x23, 0x43, 0x43, 0x35, 0x46,
        0x08, 0x35, 0x5B, 0x19, 0x30, 0x33, 0x8D, 0x00, 0x5B, 0x59, 0x9D, 0x4D,
        0x80, 0x3D, 0xED, 0x69, 0x6B, 0x43, 0x9A, 0x0A, 0x28, 0x23, 0x43, 0x43,
        0x99, 0x4D, 0x40, 0x35, 0x5B, 0x19, 0x8D, 0x00, 0x5B, 0x59, 0x93, 0x42,
        0x06, 0xD2, 0x28, 0x23, 0x43, 0x43, 0x95, 0x4D, 0x40, 0x35, 0x5B, 0x19,
        0x8D, 0x00, 0x5A, 0x51, 0x49, 0x1C, 0x0A, 0x29, 0xDF, 0xDB, 0x40, 0x1C,
        0x02, 0x28, 0xDA, 0xDB, 0x01, 0x25, 0xD0, 0xE1, 0x8A, 0x48, 0xC0, 0x6A,
        0x00, 0x28, 0x02, 0xD0, 0x88, 0x49, 0xC8, 0x6A, 0x80, 0x47, 0x24, 0x22,
        0x00, 0x21, 0x1A, 0xA8, 0x07, 0xF7, 0xE8, 0xFB, 0x69, 0x02, 0x24, 0x98,
        0x08, 0x18, 0x19, 0x90, 0x58, 0x20, 0x60, 0x43, 0x37, 0x46, 0x08, 0x37,
        0xC0, 0x19, 0x08, 0x30, 0xAF, 0x00, 0xC2, 0x59, 0xA7, 0x00, 0x82, 0x48,
        0x58, 0x38, 0xC0, 0x59, 0x80, 0x30, 0x01, 0x6B, 0x7B, 0x48, 0x03, 0x6F,
        0x19, 0x98, 0x98, 0x47, 0x11, 0x90, 0x00, 0x21, 0x17, 0xAA, 0x11, 0x98,
        0x01, 0x95, 0x00, 0x92, 0x02, 0x91, 0x03, 0x90, 0x75, 0x48, 0x03, 0x23,
        0x1A, 0xAA, 0x80, 0x21, 0x47, 0x6B, 0x19, 0x98, 0xB8, 0x47, 0x14, 0x90,
        0x14, 0x98, 0x00, 0x28, 0x02, 0xD1, 0x00, 0xBF, 0x00, 0xBF, 0x97, 0xE1,
        0x58, 0x20, 0x60, 0x43, 0x31, 0x46, 0x08, 0x31, 0x40, 0x18, 0x08, 0x30,
        0xA9, 0x00, 0x42, 0x58, 0x68, 0x48, 0x80, 0x69, 0x6D, 0x49, 0x89, 0x6B,
        0x01, 0x23, 0xDB, 0x03, 0xC9, 0x1A, 0x48, 0x43, 0x00, 0x13, 0x10, 0x1A,
        0x10, 0x90, 0x00, 0x20, 0x0F, 0x90, 0x0E, 0x90, 0x0D, 0x90, 0x01, 0x20,
        0x0C, 0x90, 0x0C, 0xA8, 0x23, 0x46, 0x2A, 0x46, 0x00, 0x90, 0x1A, 0xA8,
        0x10, 0x99, 0x02, 0xF7, 0xCB, 0xF8, 0x00, 0x28, 0x01, 0xD0, 0x01, 0x20,
        0x00, 0xE0, 0x00, 0x20, 0x0B, 0x90, 0xA2, 0x00, 0x58, 0x48, 0x5C, 0x38,
        0x80, 0x58, 0x1B, 0x99, 0x81, 0x42, 0x01, 0xD9, 0x01, 0x20, 0x00, 0xE0,
        0x00, 0x20, 0x0A, 0x90, 0x00, 0x20, 0x09, 0x90, 0x0B, 0x98, 0x00, 0x28,
        0x05, 0xD0, 0x0A, 0x98, 0x00, 0x28, 0x02, 0xD0, 0x01, 0x20, 0x09, 0x90,
        0x07, 0xE0, 0x0B, 0x98, 0x00, 0x28, 0x04, 0xD0, 0x01, 0x20, 0x0E, 0x90,
        0x0D, 0x98, 0x40, 0x1C, 0x0D, 0x90, 0x0E, 0x98, 0x00, 0x28, 0x01, 0xD0,
        0x00, 0xBF, 0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20, 0x08, 0x90,
        0x01, 0x20, 0x07, 0x90, 0x0E, 0x98, 0x00, 0x28, 0x02, 0xD0, 0x1A, 0x98,
        0x08, 0x90, 0x01, 0xE0, 0x10, 0x98, 0x08, 0x90, 0x07, 0x98, 0x00, 0x28,
        0x18, 0xD0, 0x3F, 0x48, 0x01, 0x8A, 0x40, 0x8A, 0x81, 0x42, 0x02, 0xDD,
        0x3C, 0x48, 0x41, 0x8A, 0x01, 0x82, 0x28, 0x20, 0x60, 0x43, 0x3A, 0x49,
        0x40, 0x39, 0x40, 0x18, 0xA9, 0x00, 0x47, 0x18, 0x37, 0x49, 0x0A, 0x8A,
        0x38, 0x68, 0x08, 0x99, 0x03, 0xF7, 0xB1, 0xF8, 0x38, 0x60, 0x38, 0x68,
        0x08, 0x90, 0x00, 0xBF, 0x0C, 0x98, 0x01, 0x28, 0x04, 0xD1, 0x18, 0x98,
        0x01, 0x6A, 0x10, 0x98, 0x40, 0x1A, 0x08, 0x90, 0x00, 0x20, 0x06, 0x90,
        0x0D, 0x9F, 0x12, 0xE1, 0x0B, 0x98, 0x00, 0x28, 0x3D, 0xD0, 0x09, 0x98,
        0x00, 0x28, 0x3A, 0xD1, 0x07, 0x22, 0xD2, 0x03, 0x08, 0x98, 0x80, 0x18,
        0x1D, 0x99, 0x81, 0x42, 0x33, 0xDD, 0x17, 0x98, 0x40, 0x1C, 0x4B, 0x22,
        0x50, 0x43, 0x1E, 0x99, 0x81, 0x42, 0x2C, 0xDD, 0x1B, 0x98, 0x58, 0x21,
        0x61, 0x43, 0x32, 0x46, 0x08, 0x32, 0x89, 0x18, 0x30, 0x31, 0xAA, 0x00,
        0x89, 0x58, 0x24, 0x4A, 0x80, 0x3A, 0xD2, 0x69, 0x51, 0x43, 0x89, 0x0A,
        0x03, 0x91, 0xA2, 0x00, 0x1A, 0x49, 0x5C, 0x39, 0x89, 0x58, 0x81, 0x42,
        0x03, 0xD2, 0xA2, 0x00, 0x17, 0x49, 0x5C, 0x39, 0x88, 0x58, 0x03, 0x99,
        0x88, 0x42, 0x07, 0xDD, 0x28, 0x21, 0x61, 0x43, 0x19, 0x4A, 0x40, 0x32,
        0x89, 0x18, 0xAA, 0x00, 0x88, 0x50, 0x07, 0xE0, 0x28, 0x21, 0x61, 0x43,
        0x15, 0x4B, 0x40, 0x33, 0xC9, 0x18, 0xAB, 0x00, 0x03, 0x9A, 0xCA, 0x50,
        0x00, 0xBF, 0x00, 0xBF, 0x0C, 0x20, 0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58,
        0x05, 0x22, 0xD2, 0x03, 0x10, 0x98, 0x80, 0x18, 0x81, 0x42, 0x01, 0xDA,
        0x01, 0x20, 0x0F, 0x90, 0x0C, 0x98, 0x00, 0x28, 0x16, 0xD0, 0x0C, 0x20,
        0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58, 0x08, 0x98, 0x08, 0x1A, 0x00, 0x12,
        0x05, 0x90, 0x21, 0xE0, 0x00, 0x3C, 0x20, 0x00, 0x88, 0x44, 0x20, 0x00,
        0x38, 0x3C, 0x20, 0x00, 0x08, 0x42, 0x20, 0x00, 0x3F, 0x42, 0x0F, 0x00,
        0x30, 0x75, 0x00, 0x00, 0x00, 0x3B, 0x20, 0x00, 0x0F, 0x98, 0x00, 0x28,
        0x08, 0xD0, 0x0C, 0x20, 0x78, 0x43, 0x1A, 0xA9, 0x09, 0x58, 0x10, 0x98,
        0x08, 0x1A, 0x00, 0x12, 0x05, 0x90, 0x07, 0xE0, 0x0C, 0x20, 0x78, 0x43,
        0x1A, 0xA9, 0x09, 0x58, 0x08, 0x98, 0x08, 0x1A, 0x00, 0x12, 0x05, 0x90,
        0x05, 0x98, 0x00, 0x28, 0x03, 0xDA, 0x00, 0xBF, 0x00, 0xBF, 0x00, 0x20,
        0x05, 0x90, 0x68, 0x10, 0x81, 0x00, 0x5B, 0x48, 0x40, 0x58, 0x80, 0x08,
        0x05, 0x99, 0x48, 0x43, 0x40, 0x0B, 0x59, 0x49, 0x48, 0x43, 0x57, 0x49,
        0x09, 0x1F, 0x09, 0x6B, 0x48, 0x43, 0x40, 0x0B, 0x04, 0x90, 0x04, 0x98,
        0x00, 0x28, 0x01, 0xDC, 0x01, 0x20, 0x04, 0x90, 0x0C, 0x98, 0x01, 0x28,
        0x06, 0xD1, 0x52, 0x48, 0x43, 0x6F, 0x19, 0x9A, 0x10, 0x99, 0x04, 0x98,
        0x98, 0x47, 0x04, 0x90, 0x06, 0x98, 0x02, 0x28, 0x69, 0xDA, 0x4E, 0x49,
        0x04, 0x98, 0x88, 0x42, 0x63, 0xDA, 0x00, 0xBF, 0x00, 0xBF, 0x0C, 0x21,
        0x79, 0x43, 0x1A, 0xAA, 0x89, 0x18, 0x48, 0x68, 0x17, 0x99, 0x49, 0x1C,
        0x01, 0xF7, 0x7E, 0xFC, 0x02, 0x90, 0x43, 0x48, 0x00, 0x1F, 0x00, 0x68,
        0x40, 0x68, 0x80, 0x21, 0x08, 0x40, 0x00, 0x28, 0x04, 0xD0, 0x02, 0x98,
        0xFF, 0xF7, 0x32, 0xFD, 0x01, 0x90, 0x01, 0xE0, 0x02, 0x98, 0x01, 0x90,
        0x01, 0x98, 0xFF, 0x28, 0x02, 0xDC, 0x01, 0x98, 0x00, 0x28, 0x01, 0xDA,
        0xFF, 0x20, 0x01, 0x90, 0x3B, 0x48, 0x80, 0x78, 0x40, 0x1C, 0x3A, 0x49,
        0x88, 0x70, 0x12, 0x21, 0x06, 0x98, 0x48, 0x43, 0xE1, 0x00, 0x61, 0x18,
        0x41, 0x18, 0x68, 0x1E, 0x08, 0x18, 0x03, 0x90, 0x01, 0x98, 0xC1, 0xB2,
        0x03, 0x98, 0x82, 0x00, 0x32, 0x48, 0x14, 0x30, 0x10, 0x18, 0x81, 0x70,
        0x04, 0x98, 0x81, 0xB2, 0x03, 0x98, 0x82, 0x00, 0x2E, 0x48, 0x14, 0x30,
        0x81, 0x52, 0x03, 0x98, 0x82, 0x00, 0x2C, 0x48, 0x14, 0x30, 0x10, 0x18,
        0xC5, 0x70, 0x26, 0x48, 0xFC, 0x30, 0xC1, 0x69, 0x04, 0x98, 0x81, 0x42,
        0x03, 0xD9, 0x23, 0x49, 0xFC, 0x31, 0x04, 0x98, 0xC8, 0x61, 0x21, 0x48,
        0xFC, 0x30, 0xC8, 0x22, 0x01, 0x6A, 0x04, 0x98, 0x02, 0xF7, 0x6A, 0xFF,
        0x00, 0x28, 0x09, 0xD0, 0x20, 0x48, 0x81, 0x68, 0x0C, 0x20, 0x78, 0x43,
        0x1A, 0xAA, 0x80, 0x18, 0x80, 0x68, 0x08, 0x18, 0x1C, 0x49, 0x88, 0x60,
        0x01, 0xE0, 0x00, 0xBF, 0x00, 0xBF, 0x06, 0x98, 0x40, 0x1C, 0x06, 0x90,
        0x7F, 0x1C, 0x14, 0x98, 0x87, 0x42, 0x00, 0xDA, 0xE8, 0xE6, 0x00, 0xBF,
        0x6D, 0x1C, 0x0A, 0x2D, 0x04, 0xDA, 0x15, 0x48, 0x00, 0x78, 0x00, 0x28,
        0x00, 0xD1, 0x27, 0xE6, 0x0F, 0x48, 0x23, 0x46, 0x10, 0x4A, 0x80, 0x21,
        0x45, 0x6E, 0x13, 0x98, 0xA8, 0x47, 0x10, 0x49, 0x08, 0x6B, 0x80, 0x47,
        0x61, 0x1C, 0x88, 0x42, 0x03, 0xD1, 0x07, 0x48, 0xFC, 0x30, 0xC1, 0x69,
        0x01, 0x62, 0x07, 0x48, 0x22, 0x46, 0x03, 0x6C, 0x25, 0x99, 0x24, 0x98,
        0x98, 0x47, 0x40, 0xB2, 0x23, 0x90, 0x23, 0x98, 0x63, 0xE5, 0x00, 0x00,
        0x84, 0x3A, 0x20, 0x00, 0x51, 0x07, 0x00, 0x00, 0x38, 0x3C, 0x20, 0x00,
        0xB4, 0x14, 0x00, 0x00, 0x88, 0x44, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00,
        0x38, 0x3F, 0x20, 0x00, 0xF8, 0xB5, 0x05, 0x46, 0x0E, 0x46, 0xB4, 0x20,
        0x68, 0x43, 0x0F, 0x49, 0x44, 0x18, 0xA8, 0x20, 0x00, 0x5B, 0x00, 0x04,
        0xC7, 0x0E, 0xA8, 0x20, 0x00, 0x59, 0x1F, 0x21, 0xC9, 0x02, 0x88, 0x43,
        0xA8, 0x21, 0x08, 0x51, 0x31, 0x46, 0x28, 0x46, 0x07, 0xF7, 0x0E, 0xF8,
        0xA8, 0x20, 0x00, 0x59, 0x1F, 0x21, 0xC9, 0x02, 0x88, 0x43, 0xF9, 0x02,
        0x1F, 0x22, 0xD2, 0x02, 0x11, 0x40, 0x08, 0x43, 0xA8, 0x21, 0x08, 0x51,
        0xF8, 0xBD, 0x00, 0x00, 0xCC, 0x3D, 0x20, 0x00, 0x00, 0x00, 0x88, 0x05,
        0x37, 0x0B, 0x27, 0x11, 0x65, 0x17, 0x02, 0x1E, 0x1E, 0x25, 0xBF, 0x2C,
        0xF5, 0x34, 0xC7, 0x3D, 0x27, 0x47, 0xF6, 0x50, 0x09, 0x5B, 0x38, 0x65,
        0x61, 0x6F, 0x72, 0x79, 0x62, 0x83, 0x30, 0x8D, 0xDC, 0x96, 0x62, 0xA0,
        0xBA, 0xA9, 0xD9, 0xB2, 0xAE, 0xBB, 0x2B, 0xC4, 0x3F, 0xCC, 0xE9, 0xD3,
        0x2E, 0xDB, 0x06, 0xE2, 0x8B, 0xE8, 0xB8, 0xEE, 0xA9, 0xF4, 0x68, 0xFA,
        0xFF, 0xFF, 0x00, 0x00])

    TOF_BIN_IMAGE_TERMINATION = 0x00200089
    TOF_BIN_IMAGE_START = 0x00200000
    TOF_BIN_IMAGE_END = 0x002009AC
    TOF_BIN_IMAGE_LEN = 0x000009AC


class Tmf8821App(Tmf8821Device):
    """The TMF882X application class to interface the TMF882X application as a host driver would.

        Args:
            Tmf8821Device: the base class to interact with the device.
    """

    TMF8X2X_COM_CMD_STAT = 0x08

    TMF8X2X_COM_CMD_STAT__bl_cmd_ramremap = 0x11  # Bootloader command to remap the vector table into RAM (Start RAM application).
    TMF8X2X_COM_CMD_STAT__bl_cmd_romremap = 0x12  # Bootloader command to remap the vector table into ROM (Start ROM application).
    TMF8X2X_COM_CMD_STAT__bl_cmd_debug = 0x18  # Bootloader command to unlock the SWD pins.
    TMF8X2X_COM_CMD_STAT__bl_cmd_r_ram = 0x40  # Read from BL RAM.
    TMF8X2X_COM_CMD_STAT__bl_cmd_w_ram = 0x41  # Write to BL RAM.
    TMF8X2X_COM_CMD_STAT__bl_cmd_addr_ram = 0x43  # Write to BL RAM.

    # interrupt bits
    TMF8X2X_APP_I2C_ANY_IRQ_MASK = 0x01  # any of below interrupts has occured
    TMF8X2X_APP_I2C_RESULT_IRQ_MASK = 0x02  # a measurement result is ready for readout
    TMF8X2X_APP_I2C_ALT_RESULT_IRQ_MASK = 0x04  # used for statistics and electrical calibration results
    TMF8X2X_APP_I2C_RAW_HISTOGRAM_IRQ_MASK = 0x08  # a raw histogram is ready for readout
    TMF8X2X_APP_I2C_BREAKPOINT_IRQ_MASK = 0x10  # a breakpoint has been hit
    TMF8X2X_APP_I2C_CMD_DONE_IRQ_MASK = 0x20  # a received I2C command has been handled (successfully or failed)
    TMF8X2X_APP_I2C_ERROR_IRQ_MASK = 0x40  # one of the <status> registers has been set to a non-zero value

    TMF8X2X_COM_CMD_STAT__stat_ok = 0x0  # Everything is okay
    TMF8X2X_COM_CMD_STAT__stat_accepted = 0x1  # Everything is okay too, send sop to halt ongoing command
    TMF8X2X_COM_CMD_STAT__cmd_measure = 0x10  # Start a measurement
    TMF8X2X_COM_CMD_STAT__cmd_write_config_page = 0x15  # Write the active config page
    TMF8X2X_COM_CMD_STAT__cmd_load_config_page_common = 0x16  # Load the common config page
    TMF8X2X_COM_CMD_STAT__cmd_load_config_page_spad_1 = 0x17  # load SPAD page 1
    TMF8X2X_COM_CMD_STAT__cmd_load_config_page_spad_2 = 0x18  # load SPAD page 2 (time-multiplexed)
    TMF8X2X_COM_CMD_STAT__cmd_load_config_page_factory_calib = 0x19  # load a factory calibration page
    TMF8X2X_COM_CMD_STAT__cmd_load_config_page_diagnostics = 0x1A  # load diagnostic page
    TMF8X2X_COM_CMD_STAT__cmd_factory_calibration_reset = 0x1F  # reset factory calibration state
    TMF8X2X_COM_CMD_STAT__cmd_factory_calibration = 0x20  # do a factory calibration
    TMF8X2X_COM_CMD_STAT__cmd_stop = 0xff  # Stop a measurement
    TMF8828_COM_CMD_STAT__cmd_stat__CMD_SWITCH_TMF8821_MODE = 0x65  # Switch to 3x3/3x6/4x4 mode. The device will need to be re-configured after this command. Only supported if 8x8_measurements = 1.
    TMF8828_COM_CMD_STAT__cmd_stat__CMD_SWITCH_TMF8828_MODE = 0x6C  # Switch to 8x8 mode. The device will need to be re-configured after this command. Only supported if 8x8_measurements = 1.

    TMF8X2X_BL_MAX_DATA_SIZE = 0x80  # Number of bytes that can be written or read with one BL command

    TMF8X2X_COM_APP_ID = 0x0
    TMF8X2X_COM_APP_ID__application = 0x3
    TMF8X2X_COM_APP_ID__bootloader = 0x80

    # the mode registers and its values
    TMF8828_COM_TMF8828_MODE = 0x10  # mode register is either 0x00 == tmf8820/1 or 0x08 == tmf8828
    TMF8828_COM_TMF8828_MODE__mode__TMF8821 = 0  # the device is operating in 3x3/3x6/4x4 (TMF8820/TMF8821) mode
    TMF8828_COM_TMF8828_MODE__mode__TMF8828 = 8

    TMF8X2X_HISTOGRAM_ID = 0x80  # identifying that this is a histogram frame
    TMF8X2X_RAW_HISTOGRAM_ID = 0x81
    TMF8X2X_CALIBRATION_HISTOGRAMS_ID = 0x82  # identifying electrical calibration histograms

    TMF8X2X_NO_HISTOGRAMS = 0  # no histogram is produced by device
    TMF8X2X_RAW_HISTOGRAMS = 1  # bit-mask for raw histogram dumping
    TMF8X2X_CALIBRATION_HISTOGRAMS = 2  # bit-mask for electrical calibration histogram dumping

    TMF8X2X_COM_CONFIG_RESULT = 0x20
    TMF8X2X_COM_CONFIG_RESULT_LAST = 0xdf
    TMF8X2X_COM_FC_START = 0x24
    TMF8X2X_COM_CONFIG_FACTORY_CALIB__factory_calibration_size = (
            Tmf8821Device.TMF882X_ENABLE - TMF8X2X_COM_FC_START)

    # common config page - some registers
    TMF8X2X_COM_PERIOD_MS_LSB = 0x24
    TMF8X2X_COM_PERIOD_MS_MSB = 0x25
    TMF8X2X_COM_KILO_ITERATIONS_LSB = 0x26
    TMF8X2X_COM_KILO_ITERATIONS_MSB = 0x27
    TMF8X2X_COM_CONFIDENCE_THRESHOLD = 0x30
    TMF8X2X_COM_SPAD_MAP_ID = 0x34
    TMF8X2X_COM_ALG_SETTING_0 = 0x35
    TMF8X2X_COM_HIST_DUMP = 0x39  # 0 ... all off, 1 ... raw histograms, 2 ... ec histograms]

    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_1 = 1  # 3x3 map, size 14x6 		1. Normal Mode (29°x29°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_2 = 2  # 3x3 map, size 14x9 		2. Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_3 = 3  # 3x3 map, size 14x9		3. Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_4 = 4  # 4x4 map, size 14x9		4. Time-multiplexed, Normal/Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_5 = 5  # 4x4 map, size 14x9		5. Time-multiplexed, Normal/Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_6 = 6  # 3x3 map, size 18x10		6. Normal Mode (44°x48°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_7 = 7  # 4x4 map, size 18x10		7. Time-multiplexed, Normal Mode (44°x48°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_8 = 8  # 9 zones map, size 14x9	8. Normal/Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_9 = 9  # 9 zones map, size 14x9	9. Normal/Macro Mode (29°x43,5°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_10 = 10  # 3x6 map, size 18x12       10. Time-multiplexed, (29°x57°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_11 = 11  # 3x3 map, size 14x6        11. Checkerboard, Normal Mode(29°x29°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_12 = 12  # 3x3 map, size 14x6        12. Reverse-Checkerboard, Normal Mode(29°x29°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_13 = 13  # 4x4 map, size 18x8        13. Time-multiplexed, Narrow Mode (29°x39°)
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_14 = 14  # user defined, not time multiplexed
    TMF8X2X_COM_SPAD_MAP_ID__spad_map_id__map_no_15 = 15  # 8x8 mode, user defined, time multiplexed

    TMF8X2X_COM_RESULT_FRAME_SIZE = 128 + 4  # Result + header
    TMF8X2X_COM_HISTOGRAM_FRAME_SIZE = 128 + 4 + 3  # data + header + sub-header
    TMF8X2X_MAX_CLK_CORRECTION_PAIRS = 4  # how far apart the clock correction values are (== period * this_value)
    TMF8X2X_CLK_CORRECTION_FACTOR = 5  # tmf882x clock ticks are in [0.2] microseconds, host ticks are in [1] microseconds
    TMF882X_CHANNELS = 10  # the tmf882x has native (not time-multiplexed 10 channels)
    TMF882X_CFG_IDX_FIELD = 2  # index of the configuration index field in the sub-header

    def __init__(self, ic_com: I2C_com):
        super().__init__(ic_com)
        self.host_ticks = [0 for _ in range(Tmf8821App.TMF8X2X_MAX_CLK_CORRECTION_PAIRS)]
        self.tmf8821_ticks = [0 for _ in range(Tmf8821App.TMF8X2X_MAX_CLK_CORRECTION_PAIRS)]
        self.ticks_idx = 0
        self.mode = None

    def _addClkCorrectionPair(self, host_tick: int, tmf8821_tick: int):
        """
        Add a host + device clock pair for clock correction
        Args:
            host_tick(int): The host tick at I2C read-out.
            tmf882x_tick(int): The device tick as part of the results structure.
        """
        if tmf8821_tick != 0:  # tmf882x ticks are only valid if lsb is 1, see datasheet for more details
            self.host_ticks[self.ticks_idx] = host_tick
            self.tmf8821_ticks[self.ticks_idx] = tmf8821_tick
            self.ticks_idx = self.ticks_idx + 1
            if self.ticks_idx >= Tmf8821App.TMF8X2X_MAX_CLK_CORRECTION_PAIRS:
                self.ticks_idx = 0  # wrap around

    @staticmethod
    def _computeBootloaderChecksum(data: [int]) -> int:
        """
        Compute the bootloader checksum over an array.
        Args:
            data (List[int]): The array to compute the checksum over
        Returns:
            int: the checksum
        """
        return 0xff ^ sum(data) & 0xff

    @staticmethod
    def _appendChecksumToFrame(frame: [int]) -> None:
        """
        Append a checksum it to the I2C frame.
        Args:
            frame (List[int]): The I2C command frame.
        """
        # The frame checksum is computed over all but the register byte
        checksum = Tmf8821App._computeBootloaderChecksum(frame[1:])
        frame.append(checksum)

    def isAppRunning(self):
        """
        Check if the application is running.
        Returns:
            bool: True if the application is running, False if not
        """
        val = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [self.TMF8X2X_COM_APP_ID], 1)
        return val and val[0] == self.TMF8X2X_COM_APP_ID__application

    def getAppId(self):
        """
        Get the application version.
        Returns:
            [int, int, int, int]: app_id, minor, patch, build
        """
        val = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [self.TMF8X2X_COM_APP_ID], 4)
        return list(map(int, val))

    def getAppMode(self):
        """
        The application mode (TMF8820/TMF8828)
        Returns:
            int: 8 if application is in TMF8828 mode, 0 otherwise
        """
        application_mode = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [self.TMF8828_COM_TMF8828_MODE], 1)[0]
        return self.TMF8828_COM_TMF8828_MODE__mode__TMF8828 \
            if application_mode == self.TMF8828_COM_TMF8828_MODE__mode__TMF8828 \
            else self.TMF8828_COM_TMF8828_MODE__mode__TMF8821

    def _checkRegister(self, regAddr: int, expected: int, timeout: float = 0.010):
        """
        Check that the given register reads back with the expected value within the given time
        Args:
            regAddr (int): DESCRIPTION.
            expected (int): DESCRIPTION.
            timeout (float, optional): DESCRIPTION. Defaults to 0.010.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        max_time = time.time() + timeout
        while True:
            rxed = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [regAddr], 1)
            if not rxed:
                self.error("Read register {} failed.".format(regAddr))
                return self.Status.DEV_ERROR
            if rxed[0] == expected:
                return self.Status.OK
            if time.time() > max_time:
                self.error(
                    "Read register {} timed out, expected value {}, read value {}".format(regAddr, expected, rxed[0]))
                return self.Status.TIMEOUT_ERROR

    def _sendCommand(self, cmd: int, timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Send a command to the TMF882X application, and check if it's accepted.
        Args:
            cmd (int): The command that the device shall execute.
            timeout (float, optional): _description_. Defaults to 20e-3.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        self.com.i2cTx(self.I2C_SLAVE_ADDR, [self.TMF8X2X_COM_CMD_STAT, cmd])
        expected = self.TMF8X2X_COM_CMD_STAT__stat_ok
        if cmd == self.TMF8X2X_COM_CMD_STAT__cmd_measure:
            expected = self.TMF8X2X_COM_CMD_STAT__stat_accepted
        return self._checkRegister(regAddr=self.TMF8X2X_COM_CMD_STAT, expected=expected, timeout=timeout)

    def loadConfig(self, config_page_cmd: int, timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Load the I2C configuration from the device into the register_buffer.
        Args:
            config_page_cmd (int: The config page command to be loaded (e.g. TMF8X2X_COM_CMD_STAT__cmd_load_config_page_common)
            timeout (float, optional): The maximum time we allow the application to load the configuration. Defaults to 20e-3 == 20ms.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        payload_addr = self.TMF8X2X_COM_CONFIG_RESULT
        number_regs = self.TMF8X2X_COM_CONFIG_RESULT_LAST - self.TMF8X2X_COM_CONFIG_RESULT + 1  # all
        # Tell the device to load the config, and wait until the firmware has load it.
        status = self._sendCommand(config_page_cmd, timeout)
        if status != self.Status.OK:
            return status  # sendCommand already created an error entry.
        # Now read the data via I2C, and store it in th i2C buffer for easy access.
        val = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [payload_addr], number_regs)
        if len(val) != number_regs:
            self.error("Reading the loaded config failed")
            return self.Status.DEV_ERROR
        self.register_buffer[payload_addr:payload_addr + number_regs] = val
        return self.Status.OK

    def writeConfig(self, timeout: float = 40e-3) -> Tmf8821Device.Status:
        """
        Write the I2C configuration from the register_buffer onto the device.
        Args:
            timeout (float, optional): The maximum time we allow the application to write the configuration. Defaults to 20e-3 == 20ms.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        payload_addr = self.TMF8X2X_COM_CONFIG_RESULT
        number_regs = self.TMF8X2X_COM_CONFIG_RESULT_LAST - self.TMF8X2X_COM_CONFIG_RESULT + 1  # all
        self.com.i2cTx(self.I2C_SLAVE_ADDR,
                       [payload_addr] + self.register_buffer[payload_addr:payload_addr + number_regs])
        return self._sendCommand(self.TMF8X2X_COM_CMD_STAT__cmd_write_config_page, timeout)

    def configure(self, period_in_ms: int = 33, kilo_iterations: int = 537, spad_map_id: int = 1,
                  confidence_threshold: int = 6, histograms: int = TMF8X2X_NO_HISTOGRAMS):
        """
        Function to configure some measurement parameters
        Args:
            period_in_ms (int): measurement period in milli-seconds. Defaults to 33.
            kilo_iterations (int, optional): Kilo-Iterations per measurement. Defaults to 537.
            spad_map_id (int, optional): Select one of the predefined maps (1..13). Defaults to 1.
            confidence_threshold (int, optional): Only if confidence for a target is equal or higher to this,
            it will be reported as an object. Defaults to 6.
            histograms(int,optional): whether histograms dumping is enabled or disabled. Defaults to no histograms.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        status = self.loadConfig(self.TMF8X2X_COM_CMD_STAT__cmd_load_config_page_common)
        self.register_buffer[self.TMF8X2X_COM_PERIOD_MS_LSB] = period_in_ms % 256
        self.register_buffer[self.TMF8X2X_COM_PERIOD_MS_MSB] = period_in_ms // 256
        self.register_buffer[self.TMF8X2X_COM_KILO_ITERATIONS_LSB] = kilo_iterations % 256
        self.register_buffer[self.TMF8X2X_COM_KILO_ITERATIONS_MSB] = kilo_iterations // 256
        self.register_buffer[self.TMF8X2X_COM_SPAD_MAP_ID] = spad_map_id
        self.register_buffer[self.TMF8X2X_COM_CONFIDENCE_THRESHOLD] = confidence_threshold
        self.register_buffer[self.TMF8X2X_COM_HIST_DUMP] = histograms
        if status == self.Status.OK:
            return self.writeConfig()

    def _bootloaderSendCommand(self, cmd: int, payload: [int] = [], response_payload_len: int = 0,
                               timeout: float = 100.0):
        """
        Send a command with payload, and read back response_payload_len bytes.

        Args:
            cmd (int): command code
            payload (List[int]): command payload
            response_payload_len: length of the response payload after command execution
            timeout (float, optional): command timeout in seconds
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        # The write frame consists of a command register address, command, payload len, payload, and crc
        write_frame = [self.TMF8X2X_COM_CMD_STAT, cmd, len(payload)] + payload
        # The read frame is the command register address
        read_frame = [self.TMF8X2X_COM_CMD_STAT]
        self._appendChecksumToFrame(write_frame)
        self.com.i2cTx(self.I2C_SLAVE_ADDR, write_frame)

        max_time = time.time() + timeout
        while time.time() < max_time:
            # read back status + payload_len + payload + crc
            response = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, read_frame, 3 + response_payload_len)
            if len(response) != 3 + response_payload_len:
                self.error("The application did not accept frame {}. Response is {}.".format(write_frame, response))
                return self.Status.APP_ERROR, []
            if response[0] != cmd:
                # response is ready, check if the frame is okay.
                cmd_status = response[0]
                actual_payload_len = response[1]
                payload = response[1:-1]
                checksum = response[-1]

                # Collect errors, and report at once.
                error = ""
                if cmd_status != self.TMF8X2X_COM_CMD_STAT__stat_ok:
                    error += "The bootloader returned cmd_status {}.".format(cmd_status)
                if actual_payload_len != response_payload_len:
                    error += "The bootloader payload response length should be {}, is {}.".format(actual_payload_len,
                                                                                                  response_payload_len)
                if self._computeBootloaderChecksum(payload) != checksum:
                    error += "The checksum {} does not match to the frame content.".format(checksum)

                if error:
                    self.error(
                        "{}\n Write Frame: {}, Read Frame: {}, Response {}.".format(error, write_frame, read_frame,
                                                                                    response))
                    return self.Status.APP_ERROR, bytearray()
                else:
                    # every check passed, return payload data.
                    return self.Status.OK, payload
        # timed out
        self.error("The bootloader frame {} timed out after {}s.".format(write_frame, timeout))
        return self.Status.TIMEOUT_ERROR, []

    def _bootLoaderDownloadData(self, target_address: int, data: bytearray,
                                timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Load a data chunk to the target at a specific address.
        Args:
            target_address (int): The address on the target.
            data (bytearray): The data to be written onto the target.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        # 16-bit RAM address in little endian format
        target_address_bytes = [target_address & 0xff, (target_address >> 8) & 0xff]
        # First, send the target RAM address (little endian)
        status, _ = self._bootloaderSendCommand(self.TMF8X2X_COM_CMD_STAT__bl_cmd_addr_ram, target_address_bytes)
        if status != self.Status.OK:
            self.error("Setting RAM address {} failed.".format(target_address))
            return status

        # Set the maximum chunk size that can be transferred at once.
        max_chunk_len = self.TMF8X2X_BL_MAX_DATA_SIZE
        # Split the big bytearray into smaller chunks that can be transferred with single I2C bulk writes.
        for data_idx in range(0, len(data), max_chunk_len):
            payload_data = data[data_idx: data_idx + max_chunk_len]
            self.log(
                "Loading address 0x{:x} chunk with {} bytes.".format(target_address + data_idx, len(payload_data)))
            # Write the payload of one chunk
            status, _ = self._bootloaderSendCommand(self.TMF8X2X_COM_CMD_STAT__bl_cmd_w_ram, list(payload_data))
            if status != self.Status.OK:
                self.error("Writing RAM chunk {} failed.".format(payload_data))
                return status
        return self.Status.OK

    def startRamApp(self, timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Start the ROM application from the bootloader.
        Args:
            timeout (float, optional): The communication timeout. Defaults to 20e-3.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        ram_remap_cmd = [self.TMF8X2X_COM_CMD_STAT, self.TMF8X2X_COM_CMD_STAT__bl_cmd_ramremap, 0x00]
        self._appendChecksumToFrame(ram_remap_cmd)
        self.com.i2cTx(self.I2C_SLAVE_ADDR, ram_remap_cmd)

        max_time = time.time() + timeout
        while True:  # make do-while loop, for debugging nicer
            if self.isAppRunning():
                self.mode = self.getAppMode()
                return self.Status.OK
            if time.time() > max_time:
                self.error("The application did not start within {} seconds".format(timeout))
                return self.Status.TIMEOUT_ERROR

    def downloadAndStartApp(self, timeout: float = 0.020) -> Tmf8821Device.Status:
        """
        Convenience function: does download a hex file and start the downloaded application
        Args:
            hex_file (str): The firmware/patch to load.
            timeout (float, optional): Wait time in communication before give up. Defaults to 0.020.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        status = self._bootLoaderDownloadData(BinaryImage.TOF_BIN_IMAGE_START, BinaryImage.TOF_IMAGE)
        if self.Status.OK == status:
            return self.startRamApp(timeout)
        else:
            return status

    def readResult(self) -> TMF8821ResultFrame:
        """
        Function reads a single result frame
        Returns:
            the read in result frame
        """
        fn_name = "readResult"
        frame = TMF8821ResultFrame()
        raw = self.com.i2cTxRx(self.I2C_SLAVE_ADDR, [self.TMF8X2X_COM_CONFIG_RESULT],
                               self.TMF8X2X_COM_RESULT_FRAME_SIZE)
        host_timestamp = int(time.time() * 1000 * 1000)  # need a close as possible timestamp from the host

        # measure results must start with a 0x10 as cid_rid
        if len(raw) == 0 or raw[0] != self.TMF8X2X_COM_CMD_STAT__cmd_measure:
            raw = bytearray(self.TMF8X2X_COM_RESULT_FRAME_SIZE)  # make a frame full of 0s
            self.error("{} Not a frame".format(fn_name))

        frame.unpack(raw)
        self._addClkCorrectionPair(host_timestamp, frame.payload.systemTicks)
        return frame

    def startMeasure(self, timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Functions clears and enables result interrupts, and starts a measurement.
        Args:
            timeout (float, optional): command timeout. Defaults to 0.020.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        self.host_ticks = [0 for _ in range(Tmf8821App.TMF8X2X_MAX_CLK_CORRECTION_PAIRS)]
        self.tmf8821_ticks = [0 for _ in range(Tmf8821App.TMF8X2X_MAX_CLK_CORRECTION_PAIRS)]
        self.clearAndEnableInt(self.TMF8X2X_APP_I2C_RESULT_IRQ_MASK | self.TMF8X2X_APP_I2C_RAW_HISTOGRAM_IRQ_MASK)
        return self._sendCommand(self.TMF8X2X_COM_CMD_STAT__cmd_measure, timeout=timeout)

    def stopMeasure(self, timeout: float = 20e-3) -> Tmf8821Device.Status:
        """
        Function stops a measurement and disables all interrupts.
        Args:
            timeout (float, optional): command timeout. Defaults to 0.020.
        Returns:
            Status: The status code (OK = 0, error != 0).
        """
        status = self._sendCommand(self.TMF8X2X_COM_CMD_STAT__cmd_stop, timeout=timeout)
        self.enableInt(0)  # enable no interrupt == disable all
        return status
